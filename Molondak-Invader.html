<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Molondak Invader</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0f2e 25%, #2d1b69 50%, #1a0f2e 75%, #0a0a0a 100%);
            color: #fff;
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        .game-container {
            text-align: center;
            background: linear-gradient(135deg, rgba(17, 17, 34, 0.9) 0%, rgba(34, 17, 68, 0.8) 50%, rgba(17, 17, 34, 0.9) 100%);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3), inset 0 0 20px rgba(138, 43, 226, 0.2);
            position: relative;
            border: 2px solid rgba(0, 255, 255, 0.6);
        }

        canvas {
            border: 2px solid #00ffff;
            background: linear-gradient(180deg, #000011 0%, #001122 30%, #112244 60%, #000011 100%);
            display: block;
            margin: 0 auto;
            box-shadow: inset 0 0 50px rgba(0, 100, 200, 0.3);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 18px;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }

        .controls {
            margin-top: 15px;
            font-size: 14px;
            color: #ccc;
        }

        #loadingText {
            color: #00ffff;
            font-size: 18px;
            margin: 20px 0;
            text-shadow: 0 0 10px #00ffff;
        }

        .music-controls {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }

        #musicToggle {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            border: 2px solid #00d4ff;
            border-radius: 8px;
            width: 45px;
            height: 45px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            color: #00d4ff;
            box-shadow: 
                0 0 15px rgba(0, 212, 255, 0.3),
                inset 0 0 10px rgba(0, 212, 255, 0.1);
            transition: all 0.3s ease;
            position: relative;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        #musicToggle:hover {
            transform: scale(1.05);
            box-shadow: 
                0 0 25px rgba(0, 212, 255, 0.5),
                inset 0 0 15px rgba(0, 212, 255, 0.2);
            border-color: #00ffff;
            color: #00ffff;
        }

        #musicToggle.muted {
            background: linear-gradient(135deg, #2e1a1a 0%, #3e1616 50%, #601010 100%);
            border-color: #ff4444;
            color: #ff4444;
            box-shadow: 
                0 0 15px rgba(255, 68, 68, 0.3),
                inset 0 0 10px rgba(255, 68, 68, 0.1);
        }

        #musicToggle.muted:hover {
            box-shadow: 
                0 0 25px rgba(255, 68, 68, 0.5),
                inset 0 0 15px rgba(255, 68, 68, 0.2);
        }

        #volumeSlider {
            -webkit-appearance: none;
            width: 120px;
            height: 6px;
            background: linear-gradient(90deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            border: 1px solid #00d4ff;
            border-radius: 3px;
            outline: none;
            box-shadow: 
                0 0 10px rgba(0, 212, 255, 0.2),
                inset 0 0 5px rgba(0, 0, 0, 0.5);
        }

        #volumeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 2px;
            background: linear-gradient(45deg, #00d4ff, #00ffff);
            cursor: pointer;
            border: 1px solid #ffffff;
            box-shadow: 
                0 0 8px rgba(0, 212, 255, 0.6),
                inset 0 0 3px rgba(255, 255, 255, 0.3);
            transition: all 0.2s ease;
        }

        #volumeSlider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 
                0 0 12px rgba(0, 212, 255, 0.8),
                inset 0 0 5px rgba(255, 255, 255, 0.4);
        }

        #volumeSlider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 2px;
            background: linear-gradient(45deg, #00d4ff, #00ffff);
            cursor: pointer;
            border: 1px solid #ffffff;
            box-shadow: 
                0 0 8px rgba(0, 212, 255, 0.6),
                inset 0 0 3px rgba(255, 255, 255, 0.3);
        }

        .volume-label {
            color: #00d4ff;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 5px rgba(0, 212, 255, 0.5);
            margin-left: 8px;
        }
    </style>
</head>
<body>
<div class="game-container">
    <div class="game-info" id="gameInfo" style="display: none;">
        <div>Score: <span id="score">0</span></div>
        <div>Lives: <span id="lives">3</span></div>
        <div>Level: <span id="level">1</span></div>
        <div id="formation-name" style="color: #00d4ff; font-size: 14px; text-shadow: 0 0 5px rgba(0, 212, 255, 0.5);">CLASSIC GRID</div>
    </div>

    <div id="loadingText">Loading player image...</div>
    <canvas id="gameCanvas" width="800" height="600" style="display: none;"></canvas>

    <div class="controls" id="gameControls" style="display: none;">
        Use ← → Arrow Keys to Move | Hold SPACEBAR to Shoot | P to Pause | R to Restart (when game over)<br>
        <span style="font-size: 12px; color: #888;">DEBUG: Press N to skip level and test formations</span>
    </div>
    
    <div class="music-controls">
        <button id="musicToggle">♫</button>
        <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.5">
        <span class="volume-label">AUDIO</span>
    </div>
</div>

<script>
    // ====== MUSIC SETUP ======
    const music = new Audio('https://raw.githubusercontent.com/ANThonyRix/audio_space_invaders/main/Star_wars.mp3');
    music.loop = true;
    let musicPlaying = false;
    music.volume = 0.5;

    // Set up music toggle button with Star Wars-inspired icons
    const musicToggle = document.getElementById('musicToggle');
    
    // Update button text based on state
    function updateMusicButton() {
        if (musicPlaying) {
            musicToggle.innerHTML = '♫'; // Playing icon - musical note
            musicToggle.classList.remove('muted');
            musicToggle.title = 'DISABLE AUDIO SYSTEM';
        } else {
            musicToggle.innerHTML = '✕'; // Muted/disabled icon - X mark
            musicToggle.classList.add('muted');
            musicToggle.title = 'ENABLE AUDIO SYSTEM';
        }
    }
    
    updateMusicButton(); // Initialize button state
    
    musicToggle.addEventListener('click', () => {
        if (musicPlaying) {
            music.pause();
            musicPlaying = false;
        } else {
            music.play().catch(e => {
                console.log('Music play failed, waiting for user interaction');
            });
            musicPlaying = true;
        }
        updateMusicButton();
    });

    const volumeSlider = document.getElementById('volumeSlider');
    volumeSlider.addEventListener('input', () => {
        music.volume = volumeSlider.value;
    });

    const startMusicOnInteraction = () => {
        if (!musicPlaying) {
            music.play().then(() => {
                musicPlaying = true;
                updateMusicButton();
            }).catch(e => {
                console.log('Music autoplay blocked');
            });
        }
        document.removeEventListener('keydown', startMusicOnInteraction);
        document.removeEventListener('click', startMusicOnInteraction);
    };
    
    document.addEventListener('keydown', startMusicOnInteraction);
    document.addEventListener('click', startMusicOnInteraction);

    // ====== BASIC VARIABLES ======
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    let gameState = 'loading';
    let score = 0;
    let lives = 3;
    let level = 1;
    let lastTime = 0;
    let gameOverAnimation = 0;
    let menuAnimation = 0;
    let levelCompleteAnimation = 0;

    // Space background variables
    let stars = [];
    let nebulaClouds = [];
    let spaceTime = 0;

    const playerImage = new Image();
    let imageLoaded = false;

    const enemyImages = [
        new Image(), new Image(), new Image(), new Image(), new Image()
    ];
    
    let enemyImagesLoaded = 0;
    const enemyImageUrls = [
        'https://i.postimg.cc/85B1tgYH/mouch-big.png',
        'https://i.postimg.cc/SsQ5b0sV/mosferatu.png',
        'https://i.postimg.cc/c4ZNXz79/salmonad.png',
        'https://i.postimg.cc/QMv25Yxq/mokadel.png',
        'https://i.postimg.cc/q7rnR42c/banana-chog.png'
    ];

    for (let i = 0; i < enemyImages.length; i++) {
        enemyImages[i].onload = function() {
            enemyImagesLoaded++;
            if (enemyImagesLoaded === enemyImages.length && imageLoaded) {
                document.getElementById('loadingText').style.display = 'none';
                document.getElementById('gameCanvas').style.display = 'block';
            }
        };
        enemyImages[i].src = enemyImageUrls[i];
    }

    const player = {
        x: canvas.width / 2 - 25,
        y: canvas.height - 60,
        width: 50,
        height: 50,
        speed: 5,
        color: '#00ff00'
    };

    let bullets = [];
    let invaders = [];
    let invaderBullets = [];
    let particles = [];

    const bulletSpeed = 7;
    const invaderBulletSpeed = 3;
    let invaderSpeed = 0.5; // Reduced from 1 to 0.5 (2 times slower)
    let invaderDirection = 1;
    let invaderDropDistance = 20;
    let lastInvaderShot = 0;
    let invaderShootInterval = 1000;

    const keys = {};
    let lastShot = 0;
    const shootCooldown = 300;
    let spacePressed = false;

    // ====== SPACE BACKGROUND INITIALIZATION ======
    function initializeSpace() {
        // Create twinkling stars
        stars = [];
        for (let i = 0; i < 150; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 3 + 0.5,
                brightness: Math.random(),
                twinkleSpeed: Math.random() * 0.02 + 0.01,
                color: ['#ffffff', '#ffdddd', '#ddddff', '#ddffdd', '#ffffdd'][Math.floor(Math.random() * 5)]
            });
        }

        // Create floating nebula clouds
        nebulaClouds = [];
        for (let i = 0; i < 8; i++) {
            nebulaClouds.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 100 + 50,
                opacity: Math.random() * 0.3 + 0.1,
                driftX: (Math.random() - 0.5) * 0.5,
                driftY: (Math.random() - 0.5) * 0.3,
                color: ['#4169E1', '#8A2BE2', '#FF1493', '#00CED1', '#32CD32'][Math.floor(Math.random() * 5)]
            });
        }
    }

    function drawSpaceBackground() {
        // Deep space gradient
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, '#000011');
        gradient.addColorStop(0.3, '#001122');
        gradient.addColorStop(0.7, '#112244');
        gradient.addColorStop(1, '#000011');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw nebula clouds
        nebulaClouds.forEach(cloud => {
            const gradient = ctx.createRadialGradient(
                cloud.x, cloud.y, 0,
                cloud.x, cloud.y, cloud.size
            );
            gradient.addColorStop(0, `${cloud.color}${Math.floor(cloud.opacity * 255).toString(16).padStart(2, '0')}`);
            gradient.addColorStop(1, 'transparent');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(cloud.x - cloud.size, cloud.y - cloud.size, cloud.size * 2, cloud.size * 2);
        });

        // Draw twinkling stars
        stars.forEach(star => {
            const alpha = Math.sin(spaceTime * star.twinkleSpeed) * 0.5 + 0.5;
            ctx.globalAlpha = alpha * star.brightness;
            ctx.fillStyle = star.color;
            ctx.fillRect(star.x, star.y, star.size, star.size);
        });
        ctx.globalAlpha = 1.0;

        // Add some distant galaxies/star clusters
        for (let i = 0; i < 5; i++) {
            const x = (i * 160 + spaceTime * 10) % canvas.width;
            const y = (i * 120) % canvas.height;
            
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, 30);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
            gradient.addColorStop(1, 'transparent');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(x - 30, y - 30, 60, 60);
        }
    }

    function updateSpaceBackground() {
        // Update star twinkling
        stars.forEach(star => {
            star.brightness += star.twinkleSpeed;
            if (star.brightness > 1) star.brightness = 1;
            if (star.brightness < 0) star.brightness = 0;
            if (Math.random() < 0.01) {
                star.twinkleSpeed *= -1;
            }
        });

        // Update nebula drift
        nebulaClouds.forEach(cloud => {
            cloud.x += cloud.driftX;
            cloud.y += cloud.driftY;
            
            if (cloud.x < -cloud.size) cloud.x = canvas.width + cloud.size;
            if (cloud.x > canvas.width + cloud.size) cloud.x = -cloud.size;
            if (cloud.y < -cloud.size) cloud.y = canvas.height + cloud.size;
            if (cloud.y > canvas.height + cloud.size) cloud.y = -cloud.size;
        });
    }

    // ====== LOAD PLAYER SPRITE ======
    playerImage.onload = function() {
        imageLoaded = true;
        gameState = 'menu';
        if (enemyImagesLoaded === enemyImages.length) {
            document.getElementById('loadingText').style.display = 'none';
            document.getElementById('gameCanvas').style.display = 'block';
        }
        console.log('Player image loaded successfully');
    };

    playerImage.onerror = function() {
        console.error('Failed to load player image, using fallback');
        imageLoaded = false;
        gameState = 'menu';
        document.getElementById('loadingText').textContent = 'Image failed to load, using fallback graphics';
        setTimeout(() => {
            document.getElementById('loadingText').style.display = 'none';
            document.getElementById('gameCanvas').style.display = 'block';
        }, 2000);
    };

    playerImage.src = 'https://i.postimg.cc/nVYrj9tj/molandak.png';

    // ====== INPUT HANDLERS ======
    document.addEventListener('keydown', (e) => {
        keys[e.code] = true;

        if (e.code === 'Space') {
            e.preventDefault();

            if (!spacePressed) {
                spacePressed = true;
                if (gameState === 'menu') {
                    startGame();
                } else if (gameState === 'levelComplete') {
                    continueToNextLevel();
                }
            }
        }

        if (e.code === 'Enter') {
            if (gameState === 'menu') {
                startGame();
            } else if (gameState === 'levelComplete') {
                continueToNextLevel();
            }
        }

        if (e.code === 'KeyP') {
            togglePause();
        }

        if (e.code === 'KeyR' && gameState === 'gameOver') {
            restartGame();
        }
        
        // DEBUG: Skip to next level with N key
        if (e.code === 'KeyN' && gameState === 'playing') {
            nextLevel();
        }
    });

    document.addEventListener('keyup', (e) => {
        keys[e.code] = false;

        if (e.code === 'Space') {
            spacePressed = false;
        }
    });

    canvas.addEventListener('click', (e) => {
        if (gameState === 'menu') {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const buttonX = canvas.width / 2 - 100;
            const buttonY = canvas.height / 2 + 50;
            const buttonWidth = 200;
            const buttonHeight = 60;

            if (x >= buttonX && x <= buttonX + buttonWidth &&
                y >= buttonY && y <= buttonY + buttonHeight) {
                startGame();
            }
        } else if (gameState === 'levelComplete') {
            continueToNextLevel();
        }
    });

    // ====== GAME FUNCTIONS ======
    function startGame() {
        gameState = 'playing';
        document.getElementById('gameInfo').style.display = 'flex';
        document.getElementById('gameControls').style.display = 'block';

        score = 0;
        lives = 3;
        level = 1;
        bullets = [];
        invaderBullets = [];
        particles = [];
        invaderSpeed = 0.5; // Reduced base speed (2 times slower)
        invaderDirection = 1;
        invaderShootInterval = 1000;
        player.x = canvas.width / 2 - 25;

        createInvaders();
        updateUI();
    }

    function continueToNextLevel() {
        gameState = 'playing';
        levelCompleteAnimation = 0;

        bullets = [];
        invaderBullets = [];

        player.x = canvas.width / 2 - 25;

        createInvaders();
        updateUI();
    }

    function togglePause() {
        if (gameState === 'playing') {
            gameState = 'paused';
        } else if (gameState === 'paused') {
            gameState = 'playing';
        }
    }

    function restartGame() {
        gameState = 'menu';
        score = 0;
        lives = 3;
        level = 1;
        bullets = [];
        invaderBullets = [];
        particles = [];
        invaderSpeed = 0.5; // Reduced base speed (2 times slower)
        invaderShootInterval = 1000;
        player.x = canvas.width / 2 - 25;
        gameOverAnimation = 0;
        menuAnimation = 0;
        levelCompleteAnimation = 0;

        document.getElementById('gameInfo').style.display = 'none';
        document.getElementById('gameControls').style.display = 'none';
        updateUI();
    }

    function createInvaders() {
        invaders = [];
        invaderDirection = 1;
        
        const invaderWidth = 40;
        const invaderHeight = 40;
        const spacing = 60;
        
        // Different formations for each level - now 5 formations instead of 8
        const formationPattern = (level - 1) % 5 + 1; // Cycle through 5 different patterns
        const formationNames = [
            'CLASSIC GRID',
            'ORBITAL CIRCLE',
            'CROSS FORMATION',
            'ZIGZAG WAVE',
            'DENSE SWARM'
        ];
        
        // Enhanced debug logging
        console.log(`=== CREATING INVADERS ===`);
        console.log(`Level: ${level}`);
        console.log(`Formation Pattern: ${formationPattern}`);
        console.log(`Formation Name: ${formationNames[formationPattern - 1]}`);
        console.log(`Previous invaders count: ${invaders.length}`);
        
        // Update formation name in UI
        const formationDisplay = document.getElementById('formation-name');
        if (formationDisplay) {
            formationDisplay.textContent = formationNames[formationPattern - 1];
        }
        
        switch(formationPattern) {
            case 1: // Classic formation
                console.log('Creating CLASSIC GRID formation');
                createClassicFormation(invaderWidth, invaderHeight, spacing);
                break;
            case 2: // Circle formation
                console.log('Creating ORBITAL CIRCLE formation');
                createCircleFormation(invaderWidth, invaderHeight, spacing);
                break;
            case 3: // Cross formation
                console.log('Creating CROSS FORMATION');
                createCrossFormation(invaderWidth, invaderHeight, spacing);
                break;
            case 4: // Zigzag formation
                console.log('Creating ZIGZAG WAVE formation');
                createZigzagFormation(invaderWidth, invaderHeight, spacing);
                break;
            case 5: // Dense pack formation
                console.log('Creating DENSE SWARM formation');
                createDensePackFormation(invaderWidth, invaderHeight, spacing);
                break;
        }
        
        console.log(`Created ${invaders.length} invaders in ${formationNames[formationPattern - 1]} formation for level ${level}`);
        console.log(`First invader position: x=${invaders[0]?.x}, y=${invaders[0]?.y}`);
        console.log(`=== FORMATION CREATION COMPLETE ===`);
    }
    
    function createClassicFormation(width, height, spacing) {
        // Authentic Space Invaders 5x11 grid (original game had 11 columns)
        const rows = 5;
        const cols = 11;
        const startX = (canvas.width - (cols * spacing)) / 2;
        const startY = 50;
        
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                // Original Space Invaders enemy distribution:
                // Row 0: High-value enemies (30 points)
                // Row 1: High-value enemies (30 points) 
                // Row 2: Medium-value enemies (20 points)
                // Row 3: Medium-value enemies (20 points)
                // Row 4: Low-value enemies (10 points)
                let enemyType, points, color;
                if (row < 1) {
                    enemyType = 0; points = 30; color = '#ff0000'; // Top row - highest value
                } else if (row < 3) {
                    enemyType = 1; points = 20; color = '#ffff00'; // Middle rows - medium value
                } else {
                    enemyType = 2; points = 10; color = '#00ffff'; // Bottom rows - lowest value
                }
                
                invaders.push({
                    x: startX + col * spacing,
                    y: startY + row * spacing,
                    width: width,
                    height: height,
                    row: enemyType,
                    type: enemyType < 1 ? 'small' : enemyType < 2 ? 'medium' : 'large',
                    points: points,
                    color: color
                });
            }
        }
    }
    



    function createCircleFormation(width, height, spacing) {
        // Circular formation
        const centerX = canvas.width / 2;
        const centerY = 180;
        const radius = 120;
        const numEnemies = 24;
        
        for (let i = 0; i < numEnemies; i++) {
            const angle = (i / numEnemies) * Math.PI * 2;
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * (radius * 0.6);
            const enemyType = Math.floor(i / 8); // Group by 8s
            
            invaders.push({
                x: x - width / 2,
                y: y - height / 2,
                width: width,
                height: height,
                row: enemyType,
                type: enemyType < 1 ? 'small' : enemyType < 2 ? 'medium' : 'large',
                points: enemyType < 1 ? 30 : enemyType < 2 ? 20 : 10,
                color: enemyType < 1 ? '#ff0000' : enemyType < 2 ? '#ffff00' : '#00ffff'
            });
        }
    }
    
    function createCrossFormation(width, height, spacing) {
        // Cross/Plus formation
        const centerX = canvas.width / 2;
        const centerY = 180;
        const armLength = 4;
        
        // Horizontal arm
        for (let i = -armLength; i <= armLength; i++) {
            const enemyType = Math.abs(i) < 2 ? 0 : Math.abs(i) < 4 ? 1 : 2;
            invaders.push({
                x: centerX + i * spacing,
                y: centerY,
                width: width,
                height: height,
                row: enemyType,
                type: enemyType < 1 ? 'small' : enemyType < 2 ? 'medium' : 'large',
                points: enemyType < 1 ? 30 : enemyType < 2 ? 20 : 10,
                color: enemyType < 1 ? '#ff0000' : enemyType < 2 ? '#ffff00' : '#00ffff'
            });
        }
        
        // Vertical arm (excluding center which is already placed)
        for (let i = -armLength; i <= armLength; i++) {
            if (i !== 0) { // Skip center
                const enemyType = Math.abs(i) < 2 ? 0 : Math.abs(i) < 4 ? 1 : 2;
                invaders.push({
                    x: centerX,
                    y: centerY + i * spacing,
                    width: width,
                    height: height,
                    row: enemyType,
                    type: enemyType < 1 ? 'small' : enemyType < 2 ? 'medium' : 'large',
                    points: enemyType < 1 ? 30 : enemyType < 2 ? 20 : 10,
                    color: enemyType < 1 ? '#ff0000' : enemyType < 2 ? '#ffff00' : '#00ffff'
                });
            }
        }
    }
    
    function createZigzagFormation(width, height, spacing) {
        // Zigzag pattern formation
        const rows = 6;
        const baseX = 100;
        
        for (let row = 0; row < rows; row++) {
            const numInRow = 8;
            const zigzagOffset = (row % 2) * (spacing / 2); // Alternate offset
            
            for (let col = 0; col < numInRow; col++) {
                const enemyType = Math.floor(row / 2);
                invaders.push({
                    x: baseX + col * spacing + zigzagOffset,
                    y: 60 + row * spacing,
                    width: width,
                    height: height,
                    row: enemyType,
                    type: enemyType < 2 ? 'small' : enemyType < 4 ? 'medium' : 'large',
                    points: enemyType < 2 ? 30 : enemyType < 4 ? 20 : 10,
                    color: enemyType < 2 ? '#ff0000' : enemyType < 4 ? '#ffff00' : '#00ffff'
                });
            }
        }
    }
    
    function createDensePackFormation(width, height, spacing) {
        // Dense packed formation with strategic gaps and clusters
        const rows = 8;
        const cols = 13;
        const tightSpacing = spacing * 0.7;
        const startX = (canvas.width - (cols * tightSpacing)) / 2;
        const startY = 30;
        
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                // Create strategic gaps for more interesting patterns
                // Skip corners and create defensive formations
                if ((row === 0 || row === rows-1) && (col === 0 || col === cols-1)) continue;
                if (row === 2 && col % 3 === 1) continue; // Create gaps in row 2
                if (row === 5 && col % 4 === 2) continue; // Create gaps in row 5
                
                // Create dense clusters in the center
                const isCenterCluster = (row >= 3 && row <= 4) && (col >= 5 && col <= 7);
                const enemySize = isCenterCluster ? 0.95 : 0.85; // Slightly larger in center
                
                const enemyType = Math.floor(row / 2.5);
                const actualEnemyType = Math.min(enemyType, 4);
                
                // Higher point values for center cluster
                let points = actualEnemyType < 2 ? 30 : actualEnemyType < 4 ? 20 : 10;
                if (isCenterCluster) points += 10; // Bonus points for center enemies
                
                invaders.push({
                    x: startX + col * tightSpacing,
                    y: startY + row * tightSpacing,
                    width: width * enemySize,
                    height: height * enemySize,
                    row: Math.min(actualEnemyType, 4),
                    type: actualEnemyType < 2 ? 'small' : actualEnemyType < 4 ? 'medium' : 'large',
                    points: points,
                    color: actualEnemyType < 2 ? '#ff0000' : actualEnemyType < 4 ? '#ffff00' : '#00ffff'
                });
            }
        }
    }

    function handleShooting() {
        if (keys['Space'] && gameState === 'playing') {
            const now = Date.now();
            if (now - lastShot > shootCooldown) {
                bullets.push({
                    x: player.x + player.width / 2 - 2,
                    y: player.y,
                    width: 4,
                    height: 10,
                    speed: bulletSpeed,
                    color: '#ffffff'
                });
                lastShot = now;
            }
        }
    }

    function invaderShoot() {
        const now = Date.now();
        if (now - lastInvaderShot > invaderShootInterval && invaders.length > 0) {
            const shooters = [];
            const columns = {};

            invaders.forEach(invader => {
                const col = Math.floor(invader.x / 60);
                if (!columns[col] || invader.y > columns[col].y) {
                    columns[col] = invader;
                }
            });

            Object.values(columns).forEach(invader => shooters.push(invader));

            if (shooters.length > 0) {
                const shooter = shooters[Math.floor(Math.random() * shooters.length)];
                invaderBullets.push({
                    x: shooter.x + shooter.width / 2 - 2,
                    y: shooter.y + shooter.height,
                    width: 4,
                    height: 10,
                    speed: invaderBulletSpeed,
                    color: '#ff0000'
                });
                lastInvaderShot = now;
            }
        }
    }

    function randomColor(baseColor) {
        const hueShift = Math.floor(Math.random() * 60 - 30);
        let baseHue = 0;

        if (baseColor === '#ff0000') baseHue = 0;
        else if (baseColor === '#ffff00') baseHue = 60;
        else if (baseColor === '#00ffff') baseHue = 180;
        else baseHue = Math.floor(Math.random() * 360);

        return `hsl(${(baseHue + hueShift + 360) % 360}, 100%, 50%)`;
    }

    function createExplosion(x, y, baseColor) {
        for (let i = 0; i < 20; i++) {
            particles.push({
                kind: 'explosion',
                x: x,
                y: y,
                size: Math.random() * 4 + 2,
                speedX: (Math.random() - 0.5) * 8,
                speedY: (Math.random() - 1.0) * 8,
                gravity: 0.2 + Math.random() * 0.1,
                friction: 0.98,
                life: 80 + Math.random() * 40,
                maxLife: 120,
                color: randomColor(baseColor),
                pulseSpeed: 0.1 + Math.random() * 0.2,
                baseAlpha: 0.6 + Math.random() * 0.4,
                age: 0
            });
        }
    }

    function spawnMenuParticle() {
        particles.push({
            kind: 'menu',
            x: Math.random() * canvas.width,
            y: canvas.height,
            vx: (Math.random() - 0.5) * 2,
            vy: -Math.random() * 3 - 1,
            life: 60,
            maxLife: 60,
            color: ['#00ff00', '#ffff00', '#00ffff'][Math.floor(Math.random() * 3)],
            size: 3
        });
    }

    function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            if (p.kind === 'explosion') {
                p.x += p.speedX;
                p.y += p.speedY;
                p.speedY += p.gravity;
                p.speedX *= p.friction;
                p.speedY *= p.friction;
                p.life--;
                p.age++;
                if (p.life <= 0) particles.splice(i, 1);
            } else if (p.kind === 'menu') {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }
    }

    function renderParticles() {
        for (let i = 0; i < particles.length; i++) {
            const p = particles[i];
            if (p.kind === 'explosion') {
                const pulse = Math.sin(p.age * p.pulseSpeed) * 0.5 + 0.5; 
                const fade = Math.max(p.life / p.maxLife, 0);
                const alpha = p.baseAlpha * pulse * fade;

                ctx.globalAlpha = alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            } else if (p.kind === 'menu') {
                const alpha = Math.max(p.life / p.maxLife, 0);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.size, p.size);
                ctx.globalAlpha = 1.0;
            }
        }
    }

    function update(deltaTime) {
        spaceTime += deltaTime * 0.001;
        updateSpaceBackground();

        if (gameState === 'menu') {
            menuAnimation += deltaTime * 0.003;
            if (Math.random() < 0.1) {
                spawnMenuParticle();
            }
        }

        if (gameState === 'gameOver') {
            gameOverAnimation += deltaTime * 0.005;
        }

        if (gameState === 'levelComplete') {
            levelCompleteAnimation += deltaTime * 0.005;
        }

        updateParticles();

        if (gameState !== 'playing') return;

        handleShooting();

        if (keys['ArrowLeft'] && player.x > 0) {
            player.x -= player.speed;
        }
        if (keys['ArrowRight'] && player.x < canvas.width - player.width) {
            player.x += player.speed;
        }

        bullets = bullets.filter(bullet => {
            bullet.y -= bullet.speed;
            return bullet.y > -bullet.height;
        });

        invaderBullets = invaderBullets.filter(bullet => {
            bullet.y += bullet.speed;
            return bullet.y < canvas.height;
        });

        let hitEdge = false;
        invaders.forEach(invader => {
            invader.x += invaderSpeed * invaderDirection;
            if (invader.x <= 0 || invader.x >= canvas.width - invader.width) {
                hitEdge = true;
            }
        });

        if (hitEdge) {
            invaderDirection *= -1;
            invaders.forEach(invader => {
                invader.y += invaderDropDistance;
            });
        }

        for (let bi = bullets.length - 1; bi >= 0; bi--) {
            const bullet = bullets[bi];
            for (let ii = invaders.length - 1; ii >= 0; ii--) {
                const inv = invaders[ii];
                if (bullet.x < inv.x + inv.width &&
                    bullet.x + bullet.width > inv.x &&
                    bullet.y < inv.y + inv.height &&
                    bullet.y + bullet.height > inv.y) {

                    bullets.splice(bi, 1);
                    invaders.splice(ii, 1);
                    score += inv.points;
                    createExplosion(inv.x + inv.width / 2, inv.y + inv.height / 2, inv.color);
                    break;
                }
            }
        }

        for (let i = invaderBullets.length - 1; i >= 0; i--) {
            const b = invaderBullets[i];
            if (b.x < player.x + player.width &&
                b.x + b.width > player.x &&
                b.y < player.y + player.height &&
                b.y + b.height > player.y) {

                invaderBullets.splice(i, 1);
                lives--;
                createExplosion(player.x + player.width / 2, player.y + player.height / 2, '#ff0000');

                if (lives <= 0) {
                    gameOver();
                }
            }
        }

        invaders.forEach(inv => {
            if (inv.y + inv.height >= player.y) {
                gameOver();
            }
        });

        if (invaders.length === 0) {
            nextLevel();
        }

        invaderShoot();
        updateUI();
    }

    function render() {
        drawSpaceBackground();
        renderParticles();

        if (gameState === 'menu') {
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 30;
            ctx.fillStyle = '#00ffff';
            ctx.font = 'bold 64px Courier New';
            ctx.textAlign = 'center';

            const titleY = canvas.height / 2 - 100 + Math.sin(menuAnimation) * 10;
            ctx.fillText('MOLONDAK', canvas.width / 2, titleY);

            ctx.fillStyle = '#ffff00';
            ctx.font = 'bold 48px Courier New';
            ctx.fillText('INVADER', canvas.width / 2, titleY + 60);
            ctx.shadowBlur = 0;

            const buttonX = canvas.width / 2 - 100;
            const buttonY = canvas.height / 2 + 50;
            const buttonWidth = 200;
            const buttonHeight = 60;

            const pulseAlpha = Math.sin(menuAnimation * 2) * 0.3 + 0.7;
            ctx.fillStyle = `rgba(0, 255, 255, ${pulseAlpha * 0.3})`;
            ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);

            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.strokeRect(buttonX, buttonY, buttonWidth, buttonHeight);

            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 32px Courier New';
            ctx.fillText('START', canvas.width / 2, buttonY + 40);

            ctx.fillStyle = '#cccccc';
            ctx.font = '18px Courier New';
            ctx.fillText('Click START or press SPACE/ENTER to begin', canvas.width / 2, canvas.height - 80);

            if (imageLoaded && playerImage.complete) {
                ctx.drawImage(playerImage, canvas.width / 2 - 25, canvas.height / 2 - 200, 50, 50);
            } else {
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(canvas.width / 2 - 25, canvas.height / 2 - 200, 50, 30);
            }

            return;
        }

        if (gameState === 'levelComplete') {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 20;
            ctx.fillStyle = '#00ffff';
            ctx.font = 'bold 48px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('LEVEL COMPLETE!', canvas.width / 2, canvas.height / 2 - 80);
            ctx.shadowBlur = 0;

            ctx.fillStyle = '#ffffff';
            ctx.font = '32px Courier New';
            ctx.fillText(`Next Level: ${level}`, canvas.width / 2, canvas.height / 2 - 30);

            ctx.font = '24px Courier New';
            ctx.fillText(`Score: ${score}`, canvas.width / 2, canvas.height / 2 + 10);
            
            // Show upcoming formation
            const formationNames = [
                'CLASSIC GRID',
                'ORBITAL CIRCLE',
                'CROSS FORMATION',
                'ZIGZAG WAVE',
                'DENSE SWARM'
            ];
            const nextFormationPattern = (level - 1) % 5 + 1;
            
            ctx.fillStyle = '#ffff00';
            ctx.font = 'bold 28px Courier New';
            ctx.fillText('INCOMING FORMATION:', canvas.width / 2, canvas.height / 2 + 50);
            
            ctx.shadowColor = '#ffff00';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#ffff00';
            ctx.font = 'bold 32px Courier New';
            ctx.fillText(formationNames[nextFormationPattern - 1], canvas.width / 2, canvas.height / 2 + 85);
            ctx.shadowBlur = 0;

            const blinkAlpha = Math.sin(levelCompleteAnimation * 4) * 0.5 + 0.5;
            ctx.fillStyle = `rgba(0, 255, 255, ${blinkAlpha})`;
            ctx.font = '28px Courier New';
            ctx.fillText('Press SPACE to Continue', canvas.width / 2, canvas.height / 2 + 130);
            return;
        }

        if (gameState !== 'gameOver') {
            if (imageLoaded && playerImage.complete) {
                ctx.drawImage(playerImage, player.x, player.y, player.width, player.height);
            } else {
                ctx.fillStyle = player.color;
                ctx.fillRect(player.x, player.y, player.width, player.height);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(player.x + 10, player.y + 5, 30, 5);
                ctx.fillRect(player.x + 20, player.y - 5, 10, 10);
            }

            bullets.forEach(bullet => {
                ctx.fillStyle = bullet.color;
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            });

            invaderBullets.forEach(bullet => {
                ctx.fillStyle = bullet.color;
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            });

            invaders.forEach(invader => {
                if (enemyImagesLoaded === enemyImages.length) {
                    ctx.drawImage(enemyImages[invader.row], invader.x, invader.y, invader.width, invader.height);
                } else {
                    ctx.fillStyle = invader.color;
                    ctx.fillRect(invader.x, invader.y, invader.width, invader.height);
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(invader.x + 5, invader.y + 5, 8, 8);
                    ctx.fillRect(invader.x + 27, invader.y + 5, 8, 8);
                    ctx.fillRect(invader.x + 15, invader.y + 15, 10, 5);
                }
            });
        }

        if (gameState === 'paused') {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#ffffff';
            ctx.font = '48px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
            ctx.font = '24px Courier New';
            ctx.fillText('Press P to continue', canvas.width / 2, canvas.height / 2 + 50);
        }

        if (gameState === 'gameOver') {
            const alpha = Math.min(gameOverAnimation, 1);
            ctx.fillStyle = `rgba(0, 0, 0, ${alpha * 0.8})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (alpha >= 0.5) {
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 4;
                ctx.strokeRect(50, 150, canvas.width - 100, canvas.height - 300);

                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 20;
                ctx.fillStyle = '#ff0000';
                ctx.font = 'bold 72px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 80);
                ctx.shadowBlur = 0;

                ctx.fillStyle = '#ffffff';
                ctx.font = '32px Courier New';
                ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 - 20);

                ctx.font = '24px Courier New';
                ctx.fillText(`Level Reached: ${level}`, canvas.width / 2, canvas.height / 2 + 20);

                const blinkAlpha = Math.sin(gameOverAnimation * 3) * 0.5 + 0.5;
                ctx.fillStyle = `rgba(0, 255, 0, ${blinkAlpha})`;
                ctx.font = '28px Courier New';
                ctx.fillText('Press R to Restart', canvas.width / 2, canvas.height / 2 + 80);

                ctx.fillStyle = '#cccccc';
                ctx.font = '18px Courier New';
                ctx.fillText('Press P to Pause during game', canvas.width / 2, canvas.height / 2 + 120);
            }
        }
    }

    function gameLoop(currentTime) {
        const deltaTime = currentTime - lastTime;
        lastTime = currentTime;

        update(deltaTime);
        render();

        requestAnimationFrame(gameLoop);
    }

    function updateUI() {
        document.getElementById('score').textContent = score;
        document.getElementById('lives').textContent = lives;
        document.getElementById('level').textContent = level;
    }

    function nextLevel() {
        level++;
        
        // Check if we're starting a new formation cycle (every 5 levels)
        const currentCycle = Math.floor((level - 1) / 5);
        const previousCycle = Math.floor((level - 2) / 5);
        const isNewCycle = currentCycle > previousCycle;
        
        if (isNewCycle) {
            // At the start of a new cycle, give a bigger speed boost
            invaderSpeed += 0.5; // Larger increase for new cycle
            console.log(`NEW FORMATION CYCLE ${currentCycle + 1}! Speed boosted to ${invaderSpeed}`);
        } else {
            // Normal progression within cycle - reduced increment (2x slower progression)
            invaderSpeed += 0.25; // Reduced from 0.5 to 0.25
        }
        
        invaderShootInterval = Math.max(500, invaderShootInterval - 100);

        gameState = 'levelComplete';
        levelCompleteAnimation = 0;

        // Create celebration particles
        for (let i = 0; i < 15; i++) {
            createExplosion(
                Math.random() * canvas.width,
                Math.random() * canvas.height,
                ['#00ff00', '#ffff00', '#00ffff'][Math.floor(Math.random() * 3)]
            );
        }
        
        // Log the upcoming formation for the new level
        const formationNames = [
            'CLASSIC GRID',
            'ORBITAL CIRCLE',
            'CROSS FORMATION',
            'ZIGZAG WAVE',
            'DENSE SWARM'
        ];
        const nextFormationPattern = (level - 1) % 5 + 1;
        console.log(`LEVEL ${level} INCOMING: ${formationNames[nextFormationPattern - 1]} FORMATION`);
        console.log(`Current invader speed: ${invaderSpeed}`);
    }

    function gameOver() {
        gameState = 'gameOver';
        gameOverAnimation = 0;

        for (let i = 0; i < 20; i++) {
            createExplosion(
                Math.random() * canvas.width,
                Math.random() * canvas.height,
                ['#ff0000', '#ffff00', '#ff8800'][Math.floor(Math.random() * 3)]
            );
        }
    }

    function init() {
        initializeSpace();
        updateUI();
        requestAnimationFrame(gameLoop);
    }
    init();
</script>
</body>
</html>
